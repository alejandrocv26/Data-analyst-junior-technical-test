# -*- coding: utf-8 -*-
"""THC - Jr Data Scientist Assessment-AlejandroCastano.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NBvz9uajwkosZOAclQNftdwms2Y2Zplr
"""

import pandas as pd
import numpy as np
import os
from IPython.display import display as dp

"""
In this block I access the document
"""
raw_data = pd.read_csv('/Headers.2025-03-18.na-us_R (2).csv')

"""
Quick overlook to the document content
The next two blocks basically does the same but they are not used
"""
pd(raw_data)

raw_data_route = os.path.join('/Headers.2025-03-18.na-us_R (2).csv')

#Extract
#data_extracted = pd.read_csv()
raw_data.head()

"""
In this block the total shortage amount is calculated by subtracting the actual paid amount from the invoice amount
"""

#Finding all the sortages (no matter the group, if its current or aged)
raw_data['shortages'] = raw_data['Invoice Amount'] - raw_data['Actual Paid Amount']
all_shortages = sum(raw_data['shortages'])
print(all_shortages)

"""
In this block the payment due date is converted to datetime, then is filtered by yeaar
and stored in different variables with names that are easier to understand

Then the shortages are calculated by subtracting the invoice amount from the actual paid amount
while using just the filtered data for each year

Finally is presented in a print the total shortages for each year
"""
#finding aged shortages
raw_data['Payment Due Date'] = pd.to_datetime(raw_data['Payment Due Date'], format='%d/%m/%Y')

#finding older and latest date
# *** Commented because is not needed in the output ***
#print(min(raw_data['Payment Due Date']))
#print(max(raw_data['Payment Due Date']))

#filtering transactions by year
data_2021 = raw_data[raw_data['Payment Due Date'].dt.year == 2021]
data_2022 = raw_data[raw_data['Payment Due Date'].dt.year == 2022]
data_2023 = raw_data[raw_data['Payment Due Date'].dt.year == 2023]
data_2024 = raw_data[raw_data['Payment Due Date'].dt.year == 2024]
data_2025 = raw_data[raw_data['Payment Due Date'].dt.year == 2025]

# Finding annual breakdown shortages
shortages_2021 = data_2021['Invoice Amount'] - data_2021['Actual Paid Amount']
shortages_2022 = data_2022['Invoice Amount'] - data_2022['Actual Paid Amount']
shortages_2023 = data_2023['Invoice Amount'] - data_2023['Actual Paid Amount']
shortages_2024 = data_2024['Invoice Amount'] - data_2024['Actual Paid Amount']
shortages_2025 = data_2025['Invoice Amount'] - data_2025['Actual Paid Amount']

print(f'shortages_2021: {sum(shortages_2021)}, shortages_2022: {sum(shortages_2022)}, shortages_2023: {sum(shortages_2023)}, \nshortages_2024: {sum(shortages_2024)}, shortages_2025: {sum(shortages_2025)}')

"""
In this block a column is created by converting to datetime payment due date and invoice creation date
 to find the difference in days.
 Once this column has the data stored, it's classified into 4 categories:
    1. Aged shortage
    2. Current shortage
    3. No shortage
    4. Overpaid
  depending of the shortages amounts and the difference in days
  To be finally presented in a print the total shortages for each category
"""
#Finding times where shortages have been preserved
raw_data['aged_time'] = (
    pd.to_datetime(raw_data['Payment Due Date'], format='%d/%m/%Y') - pd.to_datetime(raw_data['Invoice Creation Date'], format='%d/%m/%Y')).dt.days

# conditions
conditions = [
    (raw_data['shortages'] > 0) & (raw_data['aged_time'] > 90),
    (raw_data['shortages'] > 0) & (raw_data['aged_time'] <= 90),
    (raw_data['shortages'] == 0),
    (raw_data['shortages'] < 0)
]

choices = [
    "Aged shortage",
    "Current shortage",
    "No shortage",
    "Overpaid"
]

# apply categories
raw_data['Shortage Category'] = np.select(conditions, choices, default="Unknown")

# sum by categories
totals = raw_data.groupby('Shortage Category')['shortages'].sum()
print(totals)